# bash_prompt: user-defined prompts in interactive mode
# 
# A modification of twolfson's sexy bash prompt
# Original source from https://github.com/twolfson/sexy-bash-prompt
# Forked from gf3, https://gist.github.com/gf3/306785

# Determines whether or not to use the color prompt
COLORS_ON="0"

# Regardless, load the colors anyway at startup
# If we are on a colored terminal
if tput setaf 1 &> /dev/null; then
    # Reset the shell from our `if` check
    tput sgr0

    # Check for 256 color support
    if [[ $(tput colors) -ge 256 ]] 2>/dev/null; then
        # Use the 256 color based set
        USER_COLOR=$(tput setaf 27) #BLUE
        PRE_COLOR=$(tput setaf 7) #WHITE
        DEVICE_COLOR=$(tput setaf 39) #INDIGO
        DIR_COLOR=$(tput setaf 76) #GREEN
        GIT_STATUS_COLOR=$(tput setaf 154) #YELLOW
    else
        # Otherwise, use colors from our set of 16
        # Original colors from fork
        USER_COLOR=$(tput setaf 5) #MAGENTA
        PRE_COLOR=$(tput setaf 7) #WHITE
        DEVICE_COLOR=$(tput setaf 4) #ORANGE
        DIR_COLOR=$(tput setaf 2) #GREEN
        GIT_STATUS_COLOR=$(tput setaf 1) #PURPLE
    fi

    # Save common color actions
    BOLD=$(tput bold)
    NORMAL=$PRE_COLOR
    RESET=$(tput sgr0)
else
    # Otherwise, use ANSI escape sequences for coloring
    # Original colors from fork
    USER_COLOR="\033[1;31m" #MAGENTA
    PRE_COLOR="\033[1;37m" #WHITE
    DEVICE_COLOR="\033[1;33m" #ORANGE
    DIR_COLOR="\033[1;32m" #GREEN
    GIT_STATUS_COLOR="\033[1;35m" #PURPLE
    BOLD=""
    RESET="\033[m"
fi

function get_git_branch() {
  # Grab the branch                  | ltrim unused rows    Remove asterisk
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1/"
}

is_branch1_behind_branch2 () {
  # $ git log origin/master..master
  # commit 4a633f715caf26f6e9495198f89bba20f3402a32
  # Author: Todd Wolfson <todd@twolfson.com>
  # Date:   Sun Jul 7 22:12:17 2013 -0700
  #
  #     Unsynced commit

  # -> commit 4a633f715caf26f6e9495198f89bba20f3402a32
  # -> commit

  #           Look up if branch $1 has logs off of $2   | Pluck the first log | Return the first word "commit"
  FIRST_LOG=$(git log $1..$2 -1 --no-color 2> /dev/null | head -n1            | sed -e "s/^\(commit\).*/\1/")

  # If there was a first commit, echo out
  [[ $FIRST_LOG == "commit" ]] && echo 1
}

parse_git_ahead () {
  # Grab the local and remote branch
  BRANCH=$(get_git_branch)
  REMOTE_BRANCH=origin/$BRANCH

  # $ git log origin/master..master
  # commit 4a633f715caf26f6e9495198f89bba20f3402a32
  # Author: Todd Wolfson <todd@twolfson.com>
  # Date:   Sun Jul 7 22:12:17 2013 -0700
  #
  #     Unsynced commit

  # If the remote branch is behind the local branch
  [[ -n $(is_branch1_behind_branch2 $REMOTE_BRANCH $BRANCH) ]] ||
    # or it has not been merged into origin
    [[ $(git branch -r --no-color 2> /dev/null | grep origin/$BRANCH 2> /dev/null | tail -n 1) == "" ]] &&
    # echo our character
    echo 1
}

parse_git_behind () {
  # Grab the branch
  BRANCH=$(get_git_branch)
  REMOTE_BRANCH=origin/$BRANCH

  # $ git log master..origin/master
  # commit 4a633f715caf26f6e9495198f89bba20f3402a32
  # Author: Todd Wolfson <todd@twolfson.com>
  # Date:   Sun Jul 7 22:12:17 2013 -0700
  #
  #     Unsynced commit

  # If the local branch is behind the remote branch
  [[ -n $(is_branch1_behind_branch2 $BRANCH $REMOTE_BRANCH) ]] &&
    # echo our character
    echo 1
}

parse_git_dirty () {
  # nothing to commit, working directory clean
  # nothing to commit (working directory clean)
  [[ $(git status 2> /dev/null | tail -n 1 | sed -r "s/nothing to commit..working directory clean.?/1/") != "1" ]] && echo 1
}

function is_on_git() {
  git branch 2> /dev/null
}

function get_git_status() {
  # Grab the git dirty and git behind
  DIRTY_BRANCH=$(parse_git_dirty)
  BRANCH_AHEAD=$(parse_git_ahead)
  BRANCH_BEHIND=$(parse_git_behind)

  # Iterate through all the cases and if it matches, then echo
  if [[ $DIRTY_BRANCH == 1 && $BRANCH_AHEAD == 1 && $BRANCH_BEHIND == 1 ]]; then
    echo "⬢"
  elif [[ $DIRTY_BRANCH == 1 && $BRANCH_AHEAD == 1 ]]; then
    echo "▲"
  elif [[ $DIRTY_BRANCH == 1 && $BRANCH_BEHIND == 1 ]]; then
    echo "▼"
  elif [[ $BRANCH_AHEAD == 1 && $BRANCH_BEHIND == 1 ]]; then
    echo "⬡"
  elif [[ $BRANCH_AHEAD == 1 ]]; then
    echo "△"
  elif [[ $BRANCH_BEHIND == 1 ]]; then
    echo "▽"
  elif [[ $DIRTY_BRANCH == 1 ]]; then
    echo "*"
  fi
}

get_git_info () {
  # Grab the branch
  BRANCH=$(get_git_branch)

  # If there are any branches
  if [[ $BRANCH != "" ]]; then
    # Echo the branch
    OUTPUT=$BRANCH

    # Add on the git status
    OUTPUT=$OUTPUT"$(get_git_status)"

    # Echo our output
    echo $OUTPUT
  fi
}

# Changes the actual prompt
function load_prompt() {
    if [ $COLORS_ON -eq 1 ]; then
        PS1="\n\[${BOLD}${USER_COLOR}\]\u\[$PRE_COLOR\]@\[$DEVICE_COLOR\]\h \[$PRE_COLOR\]in \[$DIR_COLOR\]\w\[$PRE_COLOR\]\$([[ -n \$(is_on_git) ]] && echo \" on \")\[$GIT_STATUS_COLOR\]\$(get_git_info)\[$NORMAL\]\n\$ \[$RESET\]"
    else
        PS1="\n[ \u@\h in \w\$([[ -n \$(is_on_git) ]] && echo \" on \")\$(get_git_info) ]\n\$ "
    fi
}

# Toggles the colored prompt oon and off.
function toggle_prompt_colors() {
    if [ $COLORS_ON -eq 1 ]; then
        COLORS_ON="0"
    else
        COLORS_ON="1"
    fi
    load_prompt
}

# Finally, change the prompt when this is loaded
load_prompt
